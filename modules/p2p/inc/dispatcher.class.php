<?php

//--------------------------------------------------------------------------------------------------
//*	object to go through the set of received updates and raise them as events
//--------------------------------------------------------------------------------------------------

class P2P_Dispatcher {

	//----------------------------------------------------------------------------------------------
	//	properties
	//----------------------------------------------------------------------------------------------

	var $inbox = 'data/p2p/received/';		//_	location where received updates are stored [string]
	var $minPriority = 10;					//_	events with higher priority are not raised

	//----------------------------------------------------------------------------------------------
	//.	constructor
	//----------------------------------------------------------------------------------------------

	function P2P_Dispatcher() {
		global $kapenta;
		if (false == $kapenta->fs->exists($this->inbox)) {
			$kapenta->fileMakeSubdirs($this->inbox . '0.txt');
		}
	}

	//----------------------------------------------------------------------------------------------
	//.	get list of n pending events
	//----------------------------------------------------------------------------------------------
	//arg: max - maximum number of items to list [string]
	//TODO: make this more efficient by reading the locks into a separate list

	function listPending($max) {
		global $kapenta;

		$pending = array();

		$all = $kapenta->fs->listDir($this->inbox);
		sort($all);

		foreach ($all as $item) {
			if (($max > 0) && (false == strpos($item, '.lock'))) {
				$ok = true;

				if ($kapenta->fs->exists($item . '.lock')) { $ok = false; }
				
				$parts = explode('_', $item);
				$priority = (int)$parts[0];
	
				if ($priority > $this->minPriority) { $ok = false; }

				if (true == $ok) {
					$pending[] = $item;
					$max--;
				}

			} else {
				if ($max <= 0) { break; }
			}
		}

		return $pending;
	}

	//----------------------------------------------------------------------------------------------
	//.	load an dparse an event
	//----------------------------------------------------------------------------------------------
	//arg: fileName - location of a serialized event from a peer [string]
	//returns: array representation of event [array]

	function parseEvent($fileName) {
		global $kapenta;

		if (false == $kapenta->fs->exists($fileName)) {
			$event = array(
				'name' => 'admin_error', 
				'detail' => array(
					'source' => 'modules/p2p/inc/dispatcher.class.php::parseEvent(...)',
					'message' => 'event file does not exist: ' . $fileName
				)
			);
			return $event;
		}

		$parts = explode('_', basename($fileName));
		$detail = array(
			'priority' => $parts[0],
			'peer' => $parts[1],
			'rawxml' => $kapenta->fs->get($fileName)
		);

		$xd = new KXmlDocument($fileName, true);

		if (0 == count($xd->entities)) {
			$event = array(
				'name' => 'admin_error', 
				'detail' => array(
					'source' => 'modules/p2p/inc/dispatcher.class.php::parseEvent(...)',
					'message' => 'event contains missing or broken XML: ' . $fileName
				)
			);
			return $event;
		}

		$root = $xd->getEntity(1);	
		$eventName = 'p2p_' . $root['type'] . '_received';

		foreach($root['children'] as $handle) {
			$child = $xd->getEntity($handle);
			$detail[$child['type']] = $child['value'];
		}

		$event = array(
			'name' => $eventName,
			'detail' => $detail,
			'fileName' => $fileName
		);

		return $event;
	}

	//----------------------------------------------------------------------------------------------
	//.	raise an event
	//----------------------------------------------------------------------------------------------
	//arg: evt - array as generated by parseEvent above [array]

	function raiseEvent($fileName) {
		global $kapenta;
		global $kapenta;

		$debug = ('yes' == $kapenta->registry->get('p2p.debug'));

		$lockFile = $fileName . '.lock';
		if (true == $kapenta->fs->exists($lockFile)) { return false; }
		if (false == $kapenta->fs->exists($fileName)) { return false; }
		$kapenta->fs->put($lockFile, $kapenta->datetime());

		if (true == $debug) { echo "parsing file: " . $fileName . "\n"; }
		$evt = $this->parseEvent($fileName);

		if (true == $debug) {
			echo "raising event: " . $evt['name'] . "\n";
			print_r($evt);
		}

		$result = $kapenta->raiseEvent('*', $evt['name'], $evt['detail']);

		if (true == $kapenta->fs->exists($fileName)) {
			$kapenta->fileDelete($fileName, true);
			if (true == $debug) { echo "deleted event file: $fileName\n"; }
		}

		if (true == $kapenta->fs->exists($lockFile)) {
			$kapenta->fileDelete($lockFile, true);
			if (true == $debug) { echo "deleted lock file: $lockFile\n"; }
		}

		//	TODO: cron job to clear stale locks

		return $result;
	}

	//----------------------------------------------------------------------------------------------
	//.	parse and raise n events from the message queue
	//----------------------------------------------------------------------------------------------
	//arg: max - maximum number of events to raise [int]
	//opt: timeout - maximum number of seconds to work for, default is 10 minutes [int]
	//returns: number of events processed [int]

	function dispatch($max, $timeout = 600) {
		global $kapenta;

		$pending = $this->listPending($max);
		$end = ($kapenta->time() + $timeout);
		$count = 0;

		foreach($pending as $fileName) {
			if ($end <= $kapenta->time()) { break; }
			$result = $this->raiseEvent($fileName);
			$count++;
		}

		return $count;
	}

}

?>
